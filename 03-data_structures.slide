Структури от данни
14.10.2014

fmi@golang.bg
http://fmi.golang.bg/
@fmi_golang

* Но преди това...

* Въпрос за мъфин #1

Защо `9gag` не е валидно име на функция?

- Защото започва с число

* Въпрос за мъфин #2

Защо `МоятаФункция` е валидно име?

- Защото имената може да са UTF-8
- Сорс файловете на Go са в UTF-8

* Въпрос за мъфин #3

Какви символи може да има в името си една функция?

- Букви
- Цифри
- _

* Въпрос за мъфин #4

Ако имате само указател към цяло число, намиращо се в масив как ще достъпите следващото число в масива?

- Не можете, в Go няма аритметики с указатели

* Въпрос за мъфин #5

Възможна ли е такава функция: func foo(ints ...int, baba float64) float64 {...} ? Защо?

- Не, защото ... трябва да е последния аргумент

* Въпрос за мъфин #6

Как се справяме с резултат от фунцкия, който няма да използваме?

- Използвайки _

    bar, _ = foo()

* ... и няколко неща, които пропуснахме

* Функции: аргументи по подразбиране

- няма

* Това е гофер (gopher)

.image assets/gopherbw.png

* Те са сладки

.image assets/gopherswrench.jpg

* Отворете сърцето си за gopher-ите

.image assets/gopher-cute.jpg
.link http://smallfarms.oregonstate.edu


* Предаване на домашни


* Arrays

- По нашенски: масиви
- Последователност от еднакви по тип елементи
- С конкретна фиксирана дължина

.play code/03/array.go /^func main()/,/^}/

Очевидно броим от 0


* Инициализация

    var x [5]string
    x[0] = "Баба"
    x[1] = "меца"
    x[2] = "яде"
    x[3] = "от"
    x[4] = "медеца"

или накратко:

    x := [6]float64{98, 93, 77, 82, 83}

Чакай малко! Подали сме само 5 числа.

    x[5] == 0

* Полезнотии

- `len()` - връща размера като int
- `range` - ключова дума, която позволява да итерираме по индекс и стойност

    for index, value := range arr {
        ...
    }



    for index := 0; index < len(arr); index++ {
        value := arr[index]
        ...
    }

Тези два цикъла са еквивалентни


* Slices

Като масивите имат дължина и могат да се индексират, но дължината им може да се променя.

    var x []float64

Горното само създава променливата, а се инициализира по следния начин:

    x := make([]float64, 5)

Това указва на слайса да бъде с размер 5. Всеки слайс е част от масив с не по-малка дължина от слайса.

    x := make([]float64, 5, 10)

Това е същото като горното, но този слайс сочи към масив с размер 10.


* Слайсове в действие

    arr := [6]float64{1, 2, 3, 4, 5, 6}
    x := arr[1:5]

Създаваме слайс от втори до четвърти елемент включително на масива arr.

    x := arr[2:] // Взема всички без първите два елемента
    x := arr[:2] // Взема първите два елемента
    x := arr[:]  // Взема всички елементи


* Структура

.image assets/slice.jpg

    x := []int{2, 3, 5, 7, 11}

Създава нов slice, който сочи към нов масив от 5 елемента.

    y := x[1:3]

Създава нов slice, но не и нов масив - използва се вече съществуващия за x.

* Полезнотии


* len и cap

- `len(x)` - Взема размера на slice-а
- `cap(x)` - Взема размера на масива, към който slice-а сочи

.play code/03/len_vs_cap.go /^func main()/,/^}/


* append

Built-in функция, която добавя елементи към края на slice:

    sliceA := []int{1, 2, 3}
    sliceB := append(sliceA, 4, 5) // [1 2 3 4 5]

Може да добавя и един slice към друг:

    sliceC := append(sliceA, sliceB...)

Ако в резултатния slice има достатъчно място, той се използва непроменен. Ако няма, автоматично се заделя по-голям slice:

    sliceD := make([]int, 0, 3)   // len = 0, cap = 3
    sliceD = append(sliceD, 1, 2) // len = 2, cap = 3
    sliceD = append(sliceD, 2, 4) // len = 4, cap = 6

* Трик с append

Изтриване на n-ия елемент от слайс

	x := []int{1, 2, 3, 4, 5}
	x = append(x[:n], x[n+1:]...)

Ако n = 2:

	[]int{1, 2, 4, 5}


* copy

- Копира елементи от един слайс в друг
- Връща броя копирани елементи
- Source и destination може да се припокриват

    var l int
    slice1 := []int{1, 2, 3, 4}
    slice2 := []int{7, 6, 5}

Копираме трите елемента от `slice2` в `slice1`

    l = copy(slice1, slice2) // slice1 = [7 6 5 4], l = 3

Копираме края на slice1 в началото му

    l = copy(slice1, slice1[2:]) // slice1 = [3 4 3 4], l = 2

Копираме slice1 в slice2

    l = copy(slice2, slice1) // slice2 = [1 2 3], l = 3
    // Копират се само първите 3 елемента, защото len(slice2) = 3


* slice "gotchas"

1. Опит за писане в неинициализиран слайс води до паника.

2. Масивите, в които се съхраняват данните на слайсовете, не се чистят от garbage collector-a, докато има референции (слайсове) към тях.

    // WARNING: shitty code, don't do this
    func GetFileHeader(filename string) []byte {
        b, _ := ioutil.ReadFile(filename)
        return b[:10]
    }

Цялото съдържание на файла няма да бъде изчистено от паметта, докато първите 10 байта се ползват някъде.

Решение: copy() в нов слайс


* Maps

Неподредена колекция от двойки ключове и стойности

    var x map[string]int // Ключовете в x са низове, а стойностите числа


За да го инициализраме, ползваме `make`:

    x := make(map[string]int)

Подобно на слайсовете, писането в неинициализиран map води до паника.

Ползваме го почти както масиви и слайсове. Добавяне на стойност:

    x["key"] = 10

За да вземем стойност по ключ:

    value, ok := x["key"]

`ok` е `true`, ако съществува двойка с такъв ключ. В противен случай, `value` е нулевата стойност на типа (`""` за `string`) и `ok` е false.


* Полезнотии

- Бързо инициализиране:

    wordcount := map[string]int{"word1": 10, "word2": 5}

- Изтриването на стойност става с `delete`:

    x := make(map[string]int)
    delete(x, "key") // Изтрива двойката с ключ е "key". Ако няма такава, нищо не се случва.

- Проверка дали даден ключ съществува:

    if _, ok := x["key"]; ok {
        fmt.Println("key exists")
    }

- Итерирането става с `range`:

    for key, value := range m {
        fmt.Println("Key:", key, "Value:", value)
    }

* Structs

- Добре познатите C структури
- Контейнер, който съдържа полета от други типове

    type Person struct {
        name string
        age uint
    }

    var chochko Person
    chochko.name = "Чочко"
    chochko.age = 27

Други начини за инициализиране:

    chochko := Person{name: "Чочко", age: 27}
    chochko := Person{"Чочко", 27}


* new()

- Алокира памет, която да използваме за дадения тип
- Връща указател към нулирана, но не инициализирана памет

    chochko := new(Person)
    chochko.name = "Чочко"
    chochko.age = 27

- chochko е *Person, но се използва по същия начин ('cause -> is so 80s)

* new() vs. make()

new само заделя и нулира памет, а make инициализира, т.е.:

.play code/03/new_vs_make.go

- Демек `make` се ползва само върху `slice` и `map`
