Тестове и документация
23.10.2014

fmi@golang.bg
http://fmi.golang.bg/
@fmi_golang


* Въпроси за мъфини

* Колко и какви начини има за обработване на грешки в Go?

- 2
- последен резултат от функцията
- panic

* Какъв трябва да е типа на върнатата грешка (според конвенцията)?

- error - има `Error() string` метод

* За какво се използва defer?

- затваряне/изчистване на ресурси и съвземане от паника

* Къде използваме recover? Какво ще върне recover ако не сме се панирали?

- в defer, nil

* Какви са основните разлики между паниките и изключенията?

- изключението спира изпълнението в текущия блок до следващ Catch, паниката изпълнява всички defer–и и може да бъде хваната само в defer

* Какво ще изведе следния код:

  func f() {
    a := 5
    b := 10

    defer func(a int) {
      fmt.Println(a + b*2)
    }(b)

    b += a + 1
  }

- 42

* Disclamer

Днес няма да си говорим за acceptance testing, quality assurance или нещо, което се прави от "по-низшия" отдел във фирмата.

Всичко тук е дело на програмиста.


* Митът

Проектът идва с готово, подробно задание.

Прави се дизайн.

С него работата се разбива на малки задачи.

Те се извършват последователно.

За всяка от тях пишете кода и приключвате.

Изискванията не се променят, нито се добавя нова функционалност.


* Митът v2.0

Щом съм написал един код, значи ми остава единствено да го разцъкам - няколко print-а, малко пробване в main функцията и толкова.

Така или иначе няма да се променя.

А ако (не дай си боже) това се случи - аз съм го писал, знам го, няма как да допусна грешка.

Най-много да го поразцъкам още малко.


* Тежката действителност

Заданията *винаги* се променят.

Често се налага един код да се преработва.

Писането на код е сложна задача - допускат се грешки.

Програмистите са хора - допускат грешки.

Промяната на модул в единия край на системата като нищо може да счупи модул в другия край на системата.

Идва по-добра идея за реализация на кода, по ред причини.


* Искаме да автоматизираме нещата

За всичко съмнително ще пишем сценарий, който да "цъка".

Всеки сценарий ще изпълнява кода и ще прави няколко твърдения за резултатите.

Сценариите ще бъдат обединени в групи.

Пускате всички тестове с едно бутонче.

Резултатът е "Всичко мина успешно" или "Твърдения X, Y и Z в сценарии A, B и C се оказаха неверни".

Искаме да тестваме и производителността на нашия код.


* Видове тестове

- *Unit*tests* - проверяват дали дадено парче код/пакет работи правилно в изолация
- *Integration*tests* - проверяват дали няколко модула си общуват правилно
- *Functional*tests* - проверяват дали крайната функционалност е както се очаква
- *Benchmark*tests* - извикват една и съща операция `n` пъти и записват времето, отнело за изпълнение


* За какво ни помагат тестовете

- Откриват грешки по-рано
- Позволяват ни уверено да правим промени в системата
- Дават сигурност на клиенти, шефове и програмисти
- Представляват пример как се работи с кода
- Помагат разделянето на интерфейс от имплементация
- Служат като документация и спецификация
- Посочват ни слабите от към производителност части


* За какво не служат тестовете

- Не доказват, че приложението работи
- Не доказват, че приложението е с достатъчно добра производителност
- Не са Quality Assurance


* testing

Разбрахме се, че тестовете са ни супер важни.

Очевидно в стандартната библиотека на Go, има пакет за това.

За да тестваме `foo.go`, създаваме `foo_test.go` в същата директория, който тества `foo.go`

Ако тестваме пакета `foo` можем:

- Тестовите файлове също да са в пакета `foo`.
- Така имаме достъп до всичко от пакета. Публично или не.
- Тестовите файлове да са в пакет `foo_test`.
- Така имаме достъп само до публичните неща от пакета.

Или да ги смесваме.


* Тестовете в `testing`

- Дефинират се като функции, които приемат указател към `testing.T`
- Функциите трябва да започват с `Test` и слеващата буква да е главна
- Един тест минава успешно, ако не се изпълни `t.Error[f]?()`, `t.Fail()`, `t.Fatal()`...

.code code/06/testing.go /func Test/,/END TEST/

- За тестове които искаме да пропуснем викаме `t.Skip()`
- Тестовете вървят последователно освен ако не бъде извикано `t.Parallel()`
- Препоръчва се да се извика в началото на функцията
- Сигнализира че тест може да бъде изпълняван парелно с и само с други тестове извикали `t.Parallel()`

* Benchmark тестове

- Дефинират се като функции, които приемат указател към `testing.B`
- Функциите трябва да започват с `Benchmark` и слеващата буква да е главна
- Тя се състои от `for` цикъл, извикващ `b.N` пъти тестваната функция
- `go` е достатъчно умен да реши колко пъти да я извика, за да получи адекватни резултати
- Стъпките са 1, 100, 10,000, 1,000,000 50,000,000.

.link https://github.com/ChristianSiegert/go-testing-example

.code code/06/testing.go /func Bench/,/END BENCH/

* Demo

* Документиране на кода

`go` генерира автоматична документация на нашия код, вземайки под внимание:

- всеки коментар, в началото на файл

.code code/06/testing.go /\/\*/,/package fibonacci/

- всеки коментар, дефиниран над функция, метод, тип

.code code/06/testing.go /Fastest Fibonacci/,/func Fibonacci/

- всеки коментар до име в тип, var, const

.code code/06/testing.go /lookupTable stores/,/var lookupTable/


* Виждане на документацията

На всички локално инсталирани пакети

    godoc -http=:6060

Документация на (почти) всички go пакети качени в BitBucket, GitHub, Launchpad и Google Project Hosting

.link http://godoc.org/    godoc.org

* Example тестове - шантавата част

- Документация и тест в едно вътре в тестов файл
- Функцията започва с `Example`, последвана от името на типа или функцията
	Foo -> ExampleFoo
- За метод `Bar` го слагаме с подчертавка след типа `ExampleFoo_Bar`
- Пишем няколко реда, в които използваме нашия тип
- Можем да завършим с коментар започващ с `Output:` и ще бъде тествано че изхода на кода съвпада с останалата част от коментара
- Влиза в документацията на пакета като пример

.code code/06/testing.go /func Example/,/END EXAMPLE/
