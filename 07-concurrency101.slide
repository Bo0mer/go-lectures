Concurrency 101
28.10.2014

fmi@golang.bg
http://fmi.golang.bg/
@fmi_golang

* Но преди това...

* Въпрос за мъфин #1

За какво можем да ползваме тестове

- Автоматизирано откриване на грешки
- Показват относителна производителност
- Документиране и специфициране на части от приложението
- Помагат в дизайна и разгрaничаването на интерфейс и имплементация

* Въпрос за мъфин #2

За какво не можем да ползваме тестове

- Не доказват, че приложението работи
- Не доказват, че приложението е с достатъчно добра производителност
- Не са Quality Assurance

* Въпрос за мъфин #3

Какво трябва да направим за да напишем тест за пакет `foo`

- във файл завършващ с `_test.go`
- от пакет `foo` или `foo_test`
- да напишем няколко функции които започват с `Test` и приемат `*testing.T` като параметър
- и в тях да използваме `foo` и да направим твърдения за крайния резултат
- ако твърденията не са верни да извикаме `t.Error()`, `t.Fail()`, `t.Fatal()` ...

* Въпрос за мъфин #4

Какво прави `t.Parallel()`

- маркира тест че може да се изпълнява паралелно с и само с други тестове които също за извикали `t.Parallel()`

* Въпрос за мъфин #5

Как документираме go код

- всеки коментар точно преди функция или метод е документацията им
- всеки коментар точно преди тип, константа и промелнива е тяхната съответна документация
- всеки коментар преди `package ...`  e документацията на пакета
- Example тестовете също влизат в документацията


* Що е то concurrency?


* Concurrency vs. Parallelism


* Обяснение с малко повече gophers

- Лекция на Rob Pike по въпроса:

.link http://blog.golang.org/concurrency-is-not-parallelism


* Moore's law

А какво става, когато имаме много ядра?


* IO-bound vs. CPU-bound

- CPU-bound са програми, които главно зависият от време, прекарано в процесора
- IO-bound са програми, които главно зависят от време, прекарано в чакане (мрежа, памет, диск)


* Processes vs. Threads (Green & Native)

- Три начина за конкурентност
- Кой ще обясни разликите?


* Подходи

- Процеси
- Нишки (два вида)
- Актьори
- Мега умни компилатори?


* В C ползват вилици

    #include <stdio.h>

    int main()
    {
        printf("before\n");
        if (fork())
            printf("father\n");
        else
            printf("son\n");
        printf("both\n");
    }

- `fork` създава ново копие на програмата, която изпълняваме
- Всички ресурси и променливи запазват стойността си в процеса-син
- След създаването на новия процес, всички промени са локални
- Все едно клонираме хора, за да вършим повече работа едновременно


* Синхронизация на вилици

    #include <stdio.h>
    #include <unistd.h>

    int main()
    {
        pid_t pid = fork();
        if (pid == 0)
        {
            execl("/bin/sleep", "/bin/sleep", "2", (char *) 0);
        }
        else
        {
            waitpid(pid, NULL, 0);
        }
        printf("done!\n");
        return 0;
    }

- `execl` спира изпълнението на текущия процес и зарежда друг
- `waitpid` позволява на родителя да чака свършването на конкретен син


* Как работи 'ps aux | grep myprocess'?

Demo pipes.c

- `dup2` затваря подадения файлов дескриптор и дуплицира в него първия аргумент
- `close` затваря файлов дескриптов


* Предимства и недостатъци на fork

Против:

- Само за UNIX
- Създаването на нов процес е бавно и паметоемко
- Комуникацията между процеси е трудна - нямат обща памет
- Копира се памета на процеса

За:

- Копира се памета на процеса
- Стабилност
- Синът е независим - ако омаже нещо, бащата няма да пострада


* В Go се правим на модерни

- Fork не се препоръчва
- Имаме по - добър начин, за него след малко
- Ако все пак искате чрез библиотеката `syscall` можете да вдигнете нов процес
- Не го правете, ако нямате много сериозна причина


* Нишки

- Много нишки живеят в един и същи процес
- Следователно имат достъп до една и съща памет
- Глобалните променливи са общи за нишките
- Създават се бързо и лесно
- Това е концепция в операционните системи
- Някои езици ги поддържат директно
- Други ги скриват зад ниво на абстрактност


* Goroutines


* Скучно

За да се съсредоточим върху това, което се опитваме да кажем ще дадем скучен пример.

.play code/07/boring.go /func boring/,/^}/

За конкурентноста тайминга е важен. Нека е малко по - непредвидим.


* Малко по - малко скучно

Ще сложим случайно време за сън.

.play code/07/less-boring.go /func main/,/}\n}/

Скучната ни програма ще продължи да работи така до безкрайност. Като много скучна лекция, от която ви е неудобно да си тръгнете.


* Да я игнорираме

Скучната програма не заслужава вниманието ни, нека не я чакаме.

С `go` пускаме функция нормално, но пускащия няма нужда чака приключването й.

Пускаме goroutine.

.play code/07/go-less-boring.go /^package/,/^}/

Когато main приключи програмата спира.


* Да я игнорираме малко по - малко

.play code/07/go-less-boring-sleep.go /^package/,/^}/

Изпълнявахме main и скучната функция едновременно.

С края на main дойде и края на скучната функция.


* Какво е Goroutine

- Независимо изпълняваща се функция
- Практически безплатни са за създаване от към памет и процесорно време. Може да имате стотици хиляди в един процес
- Не е thread
- Зелени нишки
- Има умен scheduler, който мапва горутини към OS нишки
- Но ако мислите за тях като за много евтини нишки, няма да сте далеч от истината
- Дизайна на езика и особено go рутините са много повлияни от Communicating sequential processes на C. A. R. Hoare


* Вдъхновено от

- Последните няколко примера са безсрамно присвоени от лекция на Rob Pike. Интересна е, препоръчваме я.

.link http://www.youtube.com/watch?v=f6kdp27TYZs

- А сега да се върнем към нишки и goroutines

* Проблеми, свързани с нишки

От това, че имат една и съща памет, следва, че могат да достъпват едни и същи променливи

    int i = 0

    thread1 { i++ }
    thread2 { i++ }

    wait { thread1 } { thread2 }
    print i

Тук `i` накрая може да бъде 1 или 2.


* Критични секции

- Части от кода, които могат да бъдат изпълнени само от една нишка/процес в даден момент, се наричат критични секции
- Те са критична част от многозадачното програмиране
- Има много похвати за реализирането на критични секции.
- STM, Semaphors & Co., Message passing, Actors

В Go имаме Semaphors и Message passing


* sync

Пакет, който ни дава синхронизационни примитиви от ниско ниво:

- `Cond`
- `Mutex`
- `Once`
- `RWMutex`
- `WaitGroup`


* WaitGroup

Изчаква колекция от горутини да приключат и чак тогава продължава с изпълнението.
Така не правим простотии със `time.Sleep`, както одеве.

    package sync

    type WaitGroup struct {}

    func (*WaitGroup) Add()
    func (*WaitGroup) Done()
    func (*WaitGroup) Wait()

* Пример

.play code/07/boring-with-sync.go /^func main/,/^}/

Пак ли скуката?

* По - интересен пример

.play code/07/waitgroup.go /^func main/,/^}/


* Mutex

    package sync

    type Mutex struct {}

    func (*Mutex) Lock()
    func (*Mutex) Unlock()

- Дава достъп до даден ресурс само на една горутина по едно и също време
- Ако втора се опита да го достъпи, тя чака, докато ресурсът не бъде освободен
- Ако много горутини чакат за един ресурс, достъп се дава на една от тях на случаен принцип
- Има смисъл да се ползва като `private` атрибут на наш тип
- `Unlock()` е добра идея да бъде в `defer`
- Имплементира интерфейса `sync.Locker`


* Once

Обект от този тип ще изпълни точно една функция.

.play code/07/once.go /^func main/,/^}/


* 99% шанс за паралелизъм

- В момента *по* *подразбиране* Go кода ви ще използва само едно ядро
- В бъдеще runtime-a ще бъде по - умен и ще използва повече ядра без да се налага да правите нищо
- За сега ако го искате:

    // In your source
    runtime.GOMAXPROCS(runtime.NumCPU())

- Или

    # With environment variable
    $ GOMAXPROCS=4 go run main.go

- Нашите тестове ще са паралелизирани
