Обработване на грешки
24.11.2015

fmi@golang.bg
http://fmi.golang.bg/
@fmi_golang

* В този епизод:

- грешки
- панирания
- отлагания
- тестове
- и бумащина

* Въпрос #1:

За какво често се полва `sync.WaitGroup`?

- Изчакване на колекция от горутини да приключат и продължаване с изпълнението след това

* Въпрос #2:

За какво бихте използвали `sync.RWMutex`?

- За thread-safe достъп до споделен ресурс (променлива) от множество горутини
- Дава достъп до ресурса в даден момент само на 1 writer или на произволен брой readers
- По-ефективен от `sync.Mutex` при ситуации, в които част от горутините само четат

* Въпрос #3:

Какво ще направи select ако никой не пише в каналите му в даден момент?

- Ако има `default` код, ще го изпълни
- Ако няма, блокира докато в някой от каналите му не постъпи стойност

* Въпрос #4:

Какво би направил следния код:

.play code/errors_and_testing/muffin-q3.go /^func main/,/^}/

Who knows :)

* Въпрос #5:

Как се правят generators/iterators/lazy loading в Go?

- С канали и горутини (изненада!)
- Функция връща канал и пуска горутина, която пише стойности в него
- В зависимост от искания резултат, може да ползваме и буфериран канал


* Error handling



* Имало едно време чисто С

- Неконсистентен `error`handling`
- Понякога се приема аргумент по указател, в който се записва евентуална грешка
- Понякога се ползва връщаната стойност
- Понякога това е комбинирано с `errno`

* Пример в C

    #include <stdio.h>
    #include <errno.h>
    #include <string.h>

    extern int errno;

    int main ()
    {
        FILE* pf = fopen("unexist.txt", "rb");
        if (pf == NULL)
        {
            fprintf(stderr, "Value of errno: %d\n", errno);
            perror("Error printed by perror");
            fprintf(stderr, "Error opening file: %s\n", strerror(errno));
        }
        else
        {
            fclose(pf);
        }
        return 0;
    }

* Имало едно време един език Go

Има грубо-казано 2 начина

- 1) Връщане на грешка като (част от) резултата от функция
- 2) Изпадане в паника (носете си кърпа)


* Връщане на грешка

- Има конвенция обектите, които се връщат, да отговарят на следния интерфейс:

    type error interface {
        Error() string
    }

- Разбира се, всеки може да връща "по-сложни" обекти, даващи повече информация за грешката. Например, `os.Open` връща `os.PathError`:

    type PathError struct {
        Op string    // "open", "unlink", etc.
        Path string  // Файлът с грешката
        Err error    // Грешката, върната от system call-a
    }

    func (e *PathError) Error() string {
        return e.Op + " " + e.Path + ": " + e.Err.Error()
    }

* Стандартна употреба

    func ReadFile(filename string) ([]byte, error) {
        f, err := os.Open(filename)
        if err != nil {
            return nil, err
        }
        //...
    }

или малко по-сложно:

    func CreateFile(filename string) (*os.File, error) {
        var file, err = os.Create(filename)
        if e, ok := err.(*os.PathError); ok && e.Err == syscall.ENOSPC {
            deleteTempFiles() // Free some space
            return os.Create(filename)
        }
        return file, err
    }

* Errors are values

Често оплакване на Go програмисти е количеството проверки за грешки:

    if err != nil {
        return err
    }

- Това е донякъде вярно, особено ако даден код се обръща често към "външния свят" (`os`, `io`, `net`, etc.)
- За разлика от други езици, които може да имат exceptions и try-catch, в Go грешките се третират като нормални стойности
- Това е умишлено, защото помага за обработката на всички грешки на правилното място
- Така нямаме глобални "try-catch" блокове и изненадващи exceptions, които идват от 20 нива навътре в call stack-а
- Повече подробности на [[https://blog.golang.org/errors-are-values]]

* Пример

    if _, err := fd.Write(p0[a:b]); err != nil {
        return err
    }
    if _, err := fd.Write(p1[c:d]); err != nil {
        return err
    }
    if _, err := fd.Write(p2[e:f]); err != nil {
        return err
    }

Може да стане:

    var err error
    write := func(buf []byte) {
        if err == nil {
            _, err = w.Write(buf)
        }
    }
    write(p0[a:b])
    write(p1[c:d])
    write(p2[e:f])
    if err != nil {
        return err
    }

* defer

- `defer` е специален механизъм на езика
- `defer` добавя *извикване* на функция в един списък (стек)
- Когато обграждащата функция приключи, тези извиквания се изпълняват в обратен ред
- Използва се за сигурно и лесно почистване на ресурси (отворени файлове, заключени `mutex-и`, etc.)

* Пример:

    func CopyFile(dstName, srcName string) (written int64, err error) {
        src, err := os.Open(srcName)
        if err != nil {
            return
        }

        dst, err := os.Create(dstName)
        if err != nil {
            return
        }

        written, err = io.Copy(dst, src)
        dst.Close()
        src.Close()
        return
    }

Какви са проблемите с този код?

* По-красивият, правилен и работещ начин е това:

    func CopyFile(dstName, srcName string) (written int64, err error) {
        src, err := os.Open(srcName)
        if err != nil {
            return
        }
        defer src.Close()

        dst, err := os.Create(dstName)
        if err != nil {
            return
        }
        defer dst.Close()

        return io.Copy(dst, src)
    }

* Доуточнения

- `defer` statement-ите ни позволяват да мислим за затварянето на файловете веднага след отварянето им
- Това ни гарантира, че няма да забравим в никой случай за затварянето им, независимо кой, кога и как променя кода след нас

* Три прости правила за defer (1)

- Аргументите на `defer` се оценяват, когато самият `defer` statement се оценява

    func a() {
        i := 0
        defer fmt.Println(i)
        i++
        return
    }

- Това принтира "0"

* Три прости правила за defer (2)

- Функциите се изпълняват в `LIFO` ред

    func b() {
        for i := 0; i < 4; i++ {
            defer fmt.Print(i)
        }
    }

- Това изписва "3210"

* Три прости правила за defer (3)

- `defer` -натите функции могат да "пипат" по именованите връщани аргументи на обграждащата функция

    func c() (i int) {
        defer func() { i++ }()
        return 1
    }

- Тази функция връща "2"
- Това е удобно, за да променяме връщаните стойности от функции, примерно за да върнем грешка

* Примери

.play code/errors_and_testing/defer_example1.go /^func deferExample/,/^}/

-

.play code/errors_and_testing/defer_example2.go /^func deferExample/,/^}/

* Паника!

- Нещо като изключенията
- Ползваме ги само в крайни случаи (не като изключенията)
- Изпадайки в паника, подавате стринг с грешката
- Добрата новина е, че можете да се съвземате от тях... пак буквално


* Уточнения

- `panic` е вградена функция
- Тя спира нормалното изпълнение на програмата
- Когато функция F изпълни `panic`, изпълнението на F спира, всички `defer`-нати функции на F се изпълняват нормално, след което изпълнението се връща във функцията, извикала F
- За извикващия на F, F е все едно извикване на `panic`
- Това продължава, докато всички функции в текущата горутина (`thread`) не свършат, когато програмата гърми
- Паники се случват след директното извикване на функцията `panic`, както и след разни runtime грешки, като `out-of-bounds`array`access`

* Избягвайте ненужното изпадане в паника
.image assets/panic.jpg 550 500

* recover

- Съвзема от паника
- `recover` е безполезен без `defer` ( може да се съвземете само в defer )
- `recover` не прави нищо (връща `nil`), ако текущата горутина не е в паника
- Ако е, `recover` връща аргумента, подаден на `panic`

* Example

.code code/errors_and_testing/panic.go /^func f/,/END OMIT/
.play code/errors_and_testing/panic.go /^func main/,/^}/


* Тестове и документация

* Disclamer

Днес няма да си говорим за acceptance testing, quality assurance или нещо, което се прави от "по-низшия" отдел във фирмата.

Всичко тук е дело на програмиста.


* Митът

Проектът идва с готово, подробно задание.

Прави се дизайн.

С него работата се разбива на малки задачи.

Те се извършват последователно.

За всяка от тях пишете кода и приключвате.

Изискванията не се променят, нито се добавя нова функционалност.


* Митът v2.0

Щом съм написал един код, значи ми остава единствено да го разцъкам - няколко print-а, малко пробване в main функцията и толкова.

Така или иначе няма да се променя.

А ако (не дай си боже) това се случи - аз съм го писал, знам го, няма как да допусна грешка.

Най-много да го поразцъкам още малко.


* Тежката действителност

Заданията *винаги* се променят.

Често се налага един код да се преработва.

Писането на код е сложна задача - допускат се грешки.

Програмистите са хора - допускат грешки.

Промяната на модул в единия край на системата като нищо може да счупи модул в другия край на системата.

Идва по-добра идея за реализация на кода, по ред причини.


* Искаме да автоматизираме нещата

За всичко съмнително ще пишем сценарий, който да "цъка".

Всеки сценарий ще изпълнява кода и ще прави няколко твърдения за резултатите.

Сценариите ще бъдат обединени в групи.

Пускате всички тестове с едно бутонче.

Резултатът е "Всичко мина успешно" или "Твърдения X, Y и Z в сценарии A, B и C се оказаха неверни".

Искаме да тестваме и производителността на нашия код.


* Видове тестове

- *Unit*tests* - проверяват дали дадено парче код/пакет работи правилно в изолация
- *Integration*tests* - проверяват дали няколко модула си общуват правилно
- *Functional*tests* - проверяват дали крайната функционалност е както се очаква
- *Benchmark*tests* - извикват една и съща операция `n` пъти и записват времето, отнело за изпълнение


* За какво ни помагат тестовете

- Откриват грешки по-рано
- Позволяват ни уверено да правим промени в системата
- Улесняват работата в екип и приемствеността на проекта
- Дават сигурност на клиенти, колеги, шефове и на самите нас
- Представляват пример как се работи с кода
- Помагат разделянето на интерфейс от имплементация
- Служат като документация и спецификация
- Посочват ни слабите от към производителност части


* За какво не служат тестовете

- Не доказват, че приложението работи
- Не доказват, че приложението е с достатъчно добра производителност
- Не са Quality Assurance


* testing

Разбрахме се, че тестовете са ни супер важни.

Очевидно в стандартната библиотека на Go, има пакет за това.

За да тестваме `foo.go`, създаваме `foo_test.go` в същата директория, който тества `foo.go`

Ако тестваме пакета `foo` можем:

- Тестовите файлове също да са в пакета `foo`.
- Така имаме достъп до всичко от пакета. Публично или не.
- Тестовите файлове да са в пакет `foo_test`.
- Така имаме достъп само до публичните неща от пакета.

Или да ги смесваме.


* Тестовете в `testing`

- Дефинират се като функции, които приемат указател към `testing.T`
- Функциите трябва да започват с `Test` и слеващата буква да е главна
- Един тест минава успешно, ако не се изпълни `t.Error[f]?()`, `t.Fail()`, `t.Fatal()`...

.code code/errors_and_testing/testing.go /func Test/,/END TEST/

- За тестове които искаме да пропуснем викаме `t.Skip()`
- Тестовете вървят последователно освен ако не бъде извикано `t.Parallel()`
- Препоръчва се да се извика в началото на функцията
- Сигнализира че тест може да бъде изпълняван парелно с и само с други тестове извикали `t.Parallel()`

* Benchmark тестове

- Дефинират се като функции, които приемат указател към `testing.B`
- Функциите трябва да започват с `Benchmark` и слеващата буква да е главна
- Тя се състои от `for` цикъл, извикващ `b.N` пъти тестваната функция
- `go` е достатъчно умен да реши колко пъти да я извика, за да получи адекватни резултати
- Стъпките са 1, 100, 10,000, 1,000,000 50,000,000.

.link https://github.com/ChristianSiegert/go-testing-example

.code code/errors_and_testing/testing.go /func Bench/,/END BENCH/

* Demo

* Документиране на кода

`go` генерира автоматична документация на нашия код, вземайки под внимание:

- всеки коментар, в началото на файл

.code code/errors_and_testing/testing.go /\/\*/,/package fibonacci/

- всеки коментар, дефиниран над функция, метод, тип

.code code/errors_and_testing/testing.go /Fastest Fibonacci/,/func Fibonacci/

- всеки коментар до име в тип, var, const

.code code/errors_and_testing/testing.go /lookupTable stores/,/var lookupTable/


* Виждане на документацията

На всички локално инсталирани пакети

    godoc -http=:6060

Документация на (почти) всички go пакети качени в BitBucket, GitHub, Launchpad и Google Project Hosting

.link http://godoc.org/    godoc.org

* Example тестове - шантавата част

- Документация и тест в едно вътре в тестов файл
- Функцията започва с `Example`, последвана от името на типа или функцията
	Foo -> ExampleFoo
- За метод `Bar` го слагаме с подчертавка след типа `ExampleFoo_Bar`
- Пишем няколко реда, в които използваме нашия тип
- Можем да завършим с коментар започващ с `Output:` и ще бъде тествано че изхода на кода съвпада с останалата част от коментара
- Влиза в документацията на пакета като пример

.code code/errors_and_testing/testing.go /func Example/,/END EXAMPLE/
